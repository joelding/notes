赞誉
推荐序一
推荐序二
前言
第１章　Linux设备驱动概述及开发环境构建 1
1.1　设备驱动的作用 1
1.2　无操作系统时的设备驱动 2
1.3　有操作系统时的设备驱动 4
1.4　Linux设备驱动 5
1.4.1　设备的分类及特点 5
1.4.2　Linux设备驱动与整个软硬件系统的关系 6
1.4.3　Linux设备驱动的重点、难点 7
1.5　Linux设备驱动的开发环境构建 8
1.5.1　PC上的Linux环境 8
1.5.2　QEMU实验平台 11
1.5.3　源代码阅读和编辑 13
1.6　设备驱动Hello World：LED驱动 15
1.6.1　无操作系统时的LED驱动 15
1.6.2　Linux下的LED驱动 15
第２章　驱动设计的硬件基础 20
2.1　处理器 20
2.1.1　通用处理器 20
2.1.2　数字信号处理器 22
2.2　存储器 24
2.3　接口与总线 28
2.3.1　串口 28
2.3.2　I2C 29
2.3.3　SPI 30
2.3.4　USB 31
2.3.5　以太网接口 33
2.3.6　PCI和PCI-E 34
2.3.7　SD和SDIO 36
2.4　CPLD和FPGA 37
2.5　原理图分析 40
2.6　硬件时序分析 42
2.6.1　时序分析的概念 42
2.6.2　典型的硬件时序 43
2.7　芯片数据手册阅读方法 44
2.8　仪器仪表使用 47
2.8.1　万用表 47
2.8.2　示波器 47
2.8.3　逻辑分析仪 49
2.9　总结 51
第３章　Linux内核及内核编程 52
3.1　Linux内核的发展与演变 52
3.2　Linux 2.6后的内核特点 56
3.3　Linux内核的组成 59
3.3.1　Linux内核源代码的目录结构 59
3.3.2　Linux内核的组成部分 60
3.3.3　Linux内核空间与用户空间 64
3.4　Linux内核的编译及加载 64
3.4.1　Linux内核的编译 64
3.4.2　Kconfig和Makefile 66
3.4.3　Linux内核的引导 74
3.5　Linux下的C编程特点 75
3.5.1　Linux编码风格 75
3.5.2　GNU C与ANSI C 78
3.5.3　do { } while(0) 语句 83
3.5.4　goto语句 85
3.6　工具链 85
3.7　实验室建设 88
3.8　串口工具 89
3.9　总结 91
第４章　Linux内核模块 92
4.1　Linux内核模块简介 92
4.2　Linux内核模块程序结构 95
4.3　模块加载函数 95
4.4　模块卸载函数 97
4.5　模块参数 97
4.6　导出符号 99
4.7　模块声明与描述 100
4.8　模块的使用计数 100
4.9　模块的编译 101
4.10　使用模块“绕开”GPL 102
4.11　总结 103
第５章　Linux文件系统与设备文件 104
5.1　Linux文件操作 104
5.1.1　文件操作系统调用 104
5.1.2　C库文件操作 108
5.2　Linux文件系统 109
5.2.1　Linux文件系统目录结构 109
5.2.2　Linux文件系统与设备驱动 110
5.3　devfs 114
5.4　udev用户空间设备管理 116
5.4.1　udev与devfs的区别 116
5.4.2　sysfs文件系统与Linux设备模型 119
5.4.3　udev的组成 128
5.4.4　udev规则文件 129
5.5　总结 133
第６章　字符设备驱动 134
6.1　Linux字符设备驱动结构 134
6.1.1　cdev结构体 134
6.1.2　分配和释放设备号 136
6.1.3　f?ile_operations结构体 136
6.1.4　Linux字符设备驱动的组成 138
6.2　globalmem虚拟设备实例描述 142
6.3　globalmem设备驱动 142
6.3.1　头文件、宏及设备结构体 142
6.3.2　加载与卸载设备驱动 143
6.3.3　读写函数 144
6.3.4　seek函数 146
6.3.5　ioctl函数 146
6.3.6　使用文件私有数据 148
6.4　globalmem驱动在用户空间中的验证 156
6.5　总结 157
第７章　Linux设备驱动中的并发控制 158
7.1　并发与竞态 158
7.2　编译乱序和执行乱序 160
7.3　中断屏蔽 165
7.4　原子操作 166
7.4.1　整型原子操作 167
7.4.2　位原子操作 168
7.5　自旋锁 169
7.5.1　自旋锁的使用 169
7.5.2　读写自旋锁 173
7.5.3　顺序锁 174
7.5.4　读-复制-更新 176
7.6　信号量 181
7.7　互斥体 183
7.8　完成量 184
7.9　增加并发控制后的globalmem的设备驱动 185
7.10　总结 188
第８章　Linux设备驱动中的阻塞与非阻塞I/O 189
8.1　阻塞与非阻塞I/O 189
8.1.1　等待队列 191
8.1.2　支持阻塞操作的globalf?ifo设备驱动 194
8.1.3　在用户空间验证globalf?ifo的读写 198
8.2　轮询操作 198
8.2.1　轮询的概念与作用 198
8.2.2　应用程序中的轮询编程 199
8.2.3　设备驱动中的轮询编程 201
8.3　支持轮询操作的globalf?ifo驱动 202
8.3.1　在globalf?ifo驱动中增加轮询操作 202
8.3.2　在用户空间中验证globalf?ifo设备的轮询 203
8.4　总结 205
第９章　Linux设备驱动中的异步通知与异步I/O 206
9.1　异步通知的概念与作用 206
9.2　Linux异步通知编程 207
9.2.1　Linux信号 207
9.2.2　信号的接收 208
9.2.3　信号的释放 210
9.3　支持异步通知的globalf?ifo驱动 212
9.3.1　在globalf?ifo驱动中增加异步通知 212
9.3.2　在用户空间中验证globalf?ifo的异步通知 214
9.4　Linux异步I/O 215
9.4.1　AIO概念与GNU C库AIO 215
9.4.2　Linux内核AIO与libaio 219
9.4.3　AIO与设备驱动 222
9.5　总结 223
第10章　中断与时钟 224
10.1　中断与定时器 224
10.2　Linux中断处理程序架构 227
10.3　Linux中断编程 228
10.3.1　申请和释放中断 228
10.3.2　使能和屏蔽中断 230
10.3.3　底半部机制 230
10.3.4　实例：GPIO按键的中断 235
10.4　中断共享 237
10.5　内核定时器 238
10.5.1　内核定时器编程 238
10.5.2　内核中延迟的工作delayed_work 242
10.5.3　实例：秒字符设备 243
10.6　内核延时 247
10.6.1　短延迟 247
10.6.2　长延迟 248
10.6.3　睡着延迟 248
10.7　总结 250
第11章　内存与I/O访问 251
11.1　CPU与内存、I/O 251
11.1.1　内存空间与I/O空间 251
11.1.2　内存管理单元 252
11.2　Linux内存管理 256
11.3　内存存取 261
11.3.1　用户空间内存动态申请 261
11.3.2　内核空间内存动态申请 262
11.4　设备I/O端口和I/O内存的访问 267
11.4.1　Linux I/O端口和I/O内存访问接口 267
11.4.2　申请与释放设备的I/O端口和I/O内存 268
11.4.3　设备I/O端口和I/O内存访问流程 269
11.4.4　将设备地址映射到用户空间 270
11.5　I/O内存静态映射 276
11.6　DMA 277
11.6.1　DMA与Cache一致性 278
11.6.2　Linux下的DMA编程 279
11.7　总结 285
第12章　Linux设备驱动的软件架构思想 286
12.1　Linux驱动的软件架构 286
12.2　platform设备驱动 290
12.2.1　platform总线、设备与驱动 290
12.2.2　将globalf?ifo作为platform设备 293
12.2.3　platform设备资源和数据 295
12.3　设备驱动的分层思想 299
12.3.1　设备驱动核心层和例化 299
12.3.2　输入设备驱动 301
12.3.3　RTC设备驱动 306
12.3.4　Framebuffer设备驱动 309
12.3.5　终端设备驱动 311
12.3.6　misc设备驱动 316
12.3.7　驱动核心层 321
12.4　主机驱动与外设驱动分离的设计思想 321
12.4.1　主机驱动与外设驱动分离 321
12.4.2　Linux SPI主机和设备驱动 322
12.5　总结 330
第13章　Linux块设备驱动 331
13.1　块设备的I/O操作特点 331
13.2　Linux块设备驱动结构 332
13.2.1　block_device_operations结构体 332
13.2.2　gendisk结构体 334
13.2.3　bio、request和request_queue 335
13.2.4　I/O调度器 339
13.3　Linux块设备驱动的初始化 340
13.4　块设备的打开与释放 342
13.5　块设备驱动的ioctl函数 342
13.6　块设备驱动的I/O请求处理 343
13.6.1　使用请求队列 343
13.6.2　不使用请求队列 347
13.7　实例：vmem_disk驱动 349
13.7.1　vmem_disk的硬件原理 349
13.7.2　vmem_disk驱动模块的加载与卸载 349
13.7.3　vmem_disk设备驱动的block_device_operations 351
13.7.4　vmem_disk的I/O请求处理 352
13.8　Linux MMC子系统 354
13.9　总结 357
第14章　Linux网络设备驱动 358
14.1　Linux网络设备驱动的结构 358
14.1.1　网络协议接口层 359
14.1.2　网络设备接口层 363
14.1.3　设备驱动功能层 367
14.2　网络设备驱动的注册与注销 367
14.3　网络设备的初始化 369
14.4　网络设备的打开与释放 370
14.5　数据发送流程 371
14.6　数据接收流程 372
14.7　网络连接状态 375
14.8　参数设置和统计数据 377
14.9　DM9000网卡设备驱动实例 380
14.9.1　DM9000网卡硬件描述 380
14.9.2　DM9000网卡驱动设计分析 380
14.10　总结 386
第15章　Linux I2C核心、总线与设备驱动 387
15.1　Linux I2C体系结构 387
15.2　Linux I2C核心 394
15.3　Linux I2C适配器驱动 396
15.3.1　I2C适配器驱动的注册与注销 396
15.3.2　I2C总线的通信方法 397
15.4　Linux I2C设备驱动 399
15.4.1　Linux I2C设备驱动的模块加载与卸载 400
15.4.2　Linux I2C设备驱动的数据传输 400
15.4.3　Linux的i2c-dev.c文件分析 400
15.5　Tegra I2C总线驱动实例 405
15.6　AT24xx EEPROM的I2C设备驱动实例 410
15.7　总结 413
第16章　USB主机、设备与Gadget驱动 414
16.1　Linux USB驱动层次 414
16.1.1　主机侧与设备侧USB驱动 414
16.1.2　设备、配置、接口、端点 415
16.2　USB主机控制器驱动 420
16.2.1　USB主机控制器驱动的整体结构 420
16.2.2　实例：Chipidea USB主机驱动 425
16.3　USB设备驱动 425
16.3.1　USB设备驱动的整体结构 425
16.3.2　USB请求块 430
16.3.3　探测和断开函数 435
16.3.4　USB骨架程序 436
16.3.5　实例：USB键盘驱动 443
16.4　USB UDC与Gadget驱动 446
16.4.1　UDC和Gadget驱动的关键数据结构与API 446
16.4.2　实例：Chipidea USB UDC驱动 451
16.4.3　实例：Loopback Function驱动 453
16.5　USB OTG驱动 456
16.6　总结 458
第17章　I2C、SPI、USB驱动架构类比 459
17.1　I2C、SPI、USB驱动架构 459
17.2　I2C主机和外设眼里的Linux世界 460
第18章　ARM Linux设备树 461
18.1　ARM设备树起源 461
18.2　设备树的组成和结构 462
18.2.1　DTS、DTC和DTB等 462
18.2.2　根节点兼容性 468
18.2.3　设备节点兼容性 470
18.2.4　设备节点及label的命名 475
18.2.5　地址编码 477
18.2.6　中断连接 479
18.2.7　GPIO、时钟、pinmux连接 480
18.3　由设备树引发的BSP和驱动变更 484
18.4　常用的OF API 490
18.5　总结 493
第19章　Linux电源管理的系统架构和驱动 494
19.1　Linux电源管理的全局架构 494
19.2　CPUFreq驱动 495
19.2.1　SoC的CPUFreq驱动实现 495
19.2.2　CPUFreq的策略 501
19.2.3　CPUFreq的性能测试和调优 501
19.2.4　CPUFreq通知 502
19.3　CPUIdle驱动 504
19.4　PowerTop 508
19.5　Regulator驱动 508
19.6　OPP 511
19.7　PM QoS 515
19.8　CPU热插拔 518
19.9　挂起到RAM 522
19.10　运行时的PM 528
19.11　总结 534
第20章　Linux芯片级移植及底层驱动 535
20.1　ARM Linux底层驱动的组成和现状 535
20.2　内核节拍驱动 536
20.3　中断控制器驱动 541
20.4　SMP多核启动以及CPU热插拔驱动 549
20.5　DEBUG_LL和EARLY_PRINTK的设置 556
20.6　GPIO驱动 557
20.7　pinctrl驱动 560
20.8　时钟驱动 572
20.9　dmaengine驱动 578
20.10　总结 580
第21章　Linux设备驱动的调试 581
21.1　GDB调试器的用法 581
21.1.1　GDB的基本用法 581
21.1.2　DDD图形界面调试工具 591
21.2　Linux内核调试 594
21.3　内核打印信息——printk() 596
21.4　DEBUG_LL和EARLY_PRINTK 599
21.5　使用“/proc” 600
21.6　Oops 606
21.7　BUG_ON()和WARN_ON() 608
21.8　strace 609
21.9　KGDB 610
21.10　使用仿真器调试内核 612
21.11　应用程序调试 613
21.12　Linux性能监控与调优工具 616
21.13　总结 618