#CHAPTER 3 INTERRUPT MANAGEMENT

_Events_,  or asynchronous occurrences, originate from the environment. Event can be detected via Interrupts or be polled. In the case of using interrupts, pay attention to the processing performed inside the interrupt service routine (ISR) and outside. Each ISR is normally desirable to be kept as fast and short as possible. Events need to communicate with the main (non-ISR) code. The interrupt processing is said to have been ‘deferred’ to a ‘handler’ task. Only API functions and macros that end in ‘FromISR’ or ‘FROM_ISR’ should ever be used within an interrupt service routine.

Interrupts
- events typically generated by hardware (e.g., peripherals or external input pins) 
- cause changes in program flow control outside a normal programmed sequence
- typical sequence: 
 1. The peripheral asserts an interrupt request to the processor 
 2. The processor suspends the currently executing task 
 3. The processor executes an Interrupt Service Routine (ISR) to service the peripheral, and optionally clear the interrupt request by software if needed 
 4. The processor resumes the previously suspended task

A _Binary Semaphore_ can be used to block a _handler task_ of higher priorities. The handler task gets unblocked each time a particular interrupt occurs, effectively synchronizing the task with the interrupt. Notice that in the binary semaphore usage scenario, different from the other semaphores, the interrupt ‘giving’ the semaphore even though it has not first ‘taken’ it, and the task ‘taking’ the semaphore but never giving it back.

Example 12 "Using a binary semaphore to synchronize a task with an interrupt" demonstrates the idea behinde a binary semaphore. This example uses a binary semaphore to unblock a task from within an interrupt service routine — effectively synchronizing the task with the interrupt. A simple periodic task is used to generate an interrupt every 500 milliseconds. In this case, a software generated interrupt is used because it allows the time at which the interrupt occurs to be controlled, which in turn allows the sequence of execution to be observed more easily. Listing 45 shows the implementation of the periodic task. mainTRIGGER_INTERRUPT() simply sets a bit in the interrupt controller’s Set Pending register.

A binary semaphore is adequate if interrupts can occur only at a relatively low frequency. A binary semaphore can latch, _at most_, one interrupt event. Any subsequent events, occurring before the latched event has been processed, will be _lost_. A _Counting Semaphore_ can fix this issue.

configUSE\_COUNTING\_SEMAPHORES must be set to 1 in FreeRTOSConfig.h for counting
semaphores to be available.

Example 13. Using a counting semaphore to synchronize a task with an interrupt

Example 14. Sending and receiving on a queue from within an interrupt

_NVIC_
 - a.k.a Nested Vectored Interrupt Controller
 - a unit for interrupt handling
 - In addition to interrupt requests, there are other events that need servicing and we called them “exceptions.” 
  - Other exceptions included fault exceptions and other system exceptions to support the operating systems (e.g., SVC instruction).
  - An interrupt is one type of exception.
 - Cortex-M3 and Cortex-M4 NVIC supports 
  - up to 240 IRQs (Interrupt Requests)
  - a Non-Maskable Interrupt (NMI)
  - a SysTick (System Tick) timer interrupt
  - a number of system exceptions.
 - The Cortex-M3/M4 core can use up to eight bits to specify an interrupt priority. However, most core implementations use only some of the most significant bits, not all eight bits.
  - The higher numeric values; the lower interrupt priorities! Level 0 is the highest interrupt priority. 

The default priority for all interrupts is zero. Full interrupt nesting functionality is achieved by setting configMAX\_SYSCALL\_INTERRUPT\_PRIORITY to a higher interrupt priority (meaning a lower numeric priority value) than configKERNEL\_INTERRUPT\_PRIORITY which should almost always be set to the lowest possible interrupt priority. configMAX\_SYSCALL\_INTERRUPT\_PRIORITY defines the highest interrupt priority from which FreeRTOS API functions can be called. Interrupts that use priorities configLIBRARY\_LOWEST\_INTERRUPT\_PRIORITY to configMAX\_SYSCALL\_INTERRUPT\_PRIORITY, inclusive, are prevented from executing while the kernel or the application is inside a critical section. They can, however, make use of any API function ending in ‘FromISR’. Interrupts that use priorities (configMAX\_SYSCALL\_INTERRUPT\_PRIORITY - 1) to 0 are not affected by critical sections, so nothing the kernel does will prevent these interrupts from executing immediately - within the limitations of the microcontroller itself. Functionality that requires very strict timing belong to this category. Interrupts at these priority levels cannot use any FreeRTOS API functions.

##API FUNCTIONS
void vSemaphoreCreateBinary(xSemaphoreHandle);
portBASE\_TYPE xSemaphoreTake(xSemaphoreHandle xSemaphore, portTickType xTicksToWait );
portBASE\_TYPE xSemaphoreGiveFromISR(xSemaphoreHandle xSemaphore, portBASE_TYPE *pxHigherPriorityTaskWoken);

xSemaphoreHandle xSemaphoreCreateCounting(unsigned portBASE\_TYPE uxMaxCount, unsigned portBASE_TYPE uxInitialCount);

portBASE_TYPE xQueueSendToFrontFromISR( xQueueHandle xQueue, 
void *pvItemToQueue,
portBASE_TYPE *pxHigherPriorityTaskWoken
);

##REFERENCES
1. Richard Barry, Using the FreeRTOS Real Time Kernel - A Practical Guide - Cortex-M3 Edition, year 2010. Version 1.3.2. p.97~130
2. Joseph Yiu, The Definitive Guide to ARM Cortex -M3 and Cortex-M4 Processors, 3/E, Elsevier Inc 2014. p.229~272
3. Cutting Through the Confusion with ARM Cortex-M Interrupt Priorities Saturday, February 1st, 2014 by Miro Samek [link](http://embeddedgurus.com/state-space/2014/02/cutting-through-the-confusion-with-arm-cortex-m-interrupt-priorities/)

##TODOs
