#CHAPTER 3 INTERRUPT MANAGEMENT

_Events_,  or asynchronous occurrences, originate from the environment. Event can be detected via Interrupts or be polled. In the case of using interrupts, pay attention to the processing performed inside the interrupt service routine (ISR) and outside. Each ISR is normally desirable to be kept as short as possible. Events need to communicate with the main (non-ISR) code.

Only API functions and macros that end in ‘FromISR’ or ‘FROM_ISR’ should ever be used within an interrupt service routine.

A _Binary Semaphore_ can be used to block a _handler task_ of higher priorities. The handler task gets unblocked each time a particular interrupt occurs, effectively synchronizing the task with the interrupt.

The majority of the interrupt event processing is implemented within the synchronized task; only a very fast and short portion remaining directly in the ISR. The interrupt processing is said to have been ‘deferred’ to a ‘handler’ task.

void vSemaphoreCreateBinary(xSemaphoreHandle);
portBASE_TYPE xSemaphoreTake(xSemaphoreHandle, portTickType);
xSemaphoreGiveFromISR(xSemaphoreHandle, portBASE_TYPE*);

##REFERENCES
[1] Richard Barry, Using the FreeRTOS Real Time Kernel - A Practical Guide - Cortex-M3 Edition, year 2010. Version 1.3.2. p.97~130
