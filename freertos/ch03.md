#CHAPTER 3 INTERRUPT MANAGEMENT

_Events_,  or asynchronous occurrences, originate from the environment. Event can be detected via Interrupts or be polled. In the case of using interrupts, pay attention to the processing performed inside the interrupt service routine (ISR) and outside. Each ISR is normally desirable to be kept as short as possible. Events need to communicate with the main (non-ISR) code.

Only API functions and macros that end in ‘FromISR’ or ‘FROM_ISR’ should ever be used within an interrupt service routine.

A _Binary Semaphore_ can be used to block a _handler task_ of higher priorities. The handler task gets unblocked each time a particular interrupt occurs, effectively synchronizing the task with the interrupt.

The majority of the interrupt event processing is implemented within the synchronized task; only a very fast and short portion remaining directly in the ISR. The interrupt processing is said to have been ‘deferred’ to a ‘handler’ task.

In the binary semaphore usage scenario, different from the other semaphores, the interrupt ‘giving’ the semaphore even though it has not first ‘taken’ it, and the task ‘taking’ the semaphore but never giving it back.

Example 12. Using a binary semaphore to synchronize a task with an interrupt

This example uses a binary semaphore to unblock a task from within an interrupt service routine—effectively synchronizing the task with the interrupt. A simple periodic task is used to generate an interrupt every 500 milliseconds. In this case, a software generated interrupt is used because it allows the time at which the interrupt occurs to be controlled, which in turn allows the sequence of execution to be observed more easily. Listing 45 shows the implementation of the periodic task. mainTRIGGER_INTERRUPT() simply sets a bit in the interrupt controller’s Set Pending register.

adequate if interrupts can occur only at a relatively low frequency.

configUSE_COUNTING_SEMAPHORES must be set to 1 in FreeRTOSConfig.h for counting
semaphores to be available.

Example 13. Using a counting semaphore to synchronize a task with an interrupt

Example 14. Sending and receiving on a queue from within an interrupt

##API FUNCTIONS
void vSemaphoreCreateBinary(xSemaphoreHandle);
portBASE\_TYPE xSemaphoreTake(xSemaphoreHandle xSemaphore, portTickType xTicksToWait );
portBASE\_TYPE xSemaphoreGiveFromISR(xSemaphoreHandle xSemaphore, portBASE_TYPE *pxHigherPriorityTaskWoken);

xSemaphoreHandle xSemaphoreCreateCounting(unsigned portBASE\_TYPE uxMaxCount, unsigned portBASE_TYPE uxInitialCount);

portBASE_TYPE xQueueSendToFrontFromISR( xQueueHandle xQueue, 
void *pvItemToQueue,
portBASE_TYPE *pxHigherPriorityTaskWoken
);

##REFERENCES
[1] Richard Barry, Using the FreeRTOS Real Time Kernel - A Practical Guide - Cortex-M3 Edition, year 2010. Version 1.3.2. p.97~130
